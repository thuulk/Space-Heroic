# Module created to define and store functions of Space_Heroic source code
import random

from classes import game, bullet, enemies, player, timer, meteors
from pygame import mixer
import pygame
import math


# Function that initialize everything required for the game to run.
def initialize():

    # Initialize pygame.
    pygame.init()

    # Initialize music and main theme
    pygame.mixer.init()
    mixer.music.load('corneria.mp3')
    mixer.music.set_volume(1)
    mixer.music.play(-1)

    # Setting the frame rate in which the screen updates.
    timer.clock.tick(60)

    # Respawning enemies and player
    for enemy in range(enemies.quantity):
        enemies.regenerate_object(enemy, 0, 200, True)

    for iteration in range(player.quantity):
        player.regenerate_object(iteration, 0, 0, False, 368, 518)
        bullet.visible = False

    for meteor in range(meteors.quantity):
        meteors.regenerate_object(meteor, 0, 0, False, random.randint(0, 736), random.randint(-256, -128))

    # Resetting score
    game.score = 0


# Function that resets the music to the beginning.
def reinitialize_music():

    mixer.music.stop()
    mixer.music.play()


# Hitbox function.
def hitbox(position_x_1, position_y_1, position_x_2, position_y_2, distance_pixels):

    bullet_n_enemy_distance = math.sqrt(math.pow(position_x_1 - position_x_2, 2) +
                                        math.pow(position_y_1 - position_y_2, 2))

    if bullet_n_enemy_distance < distance_pixels:
        return True

    else:
        return False


# Function that contains the block code that conforms the main menu.
def game_menu():

    # Displaying the background, game title, and the options the user can choose (play or exit the game).
    game.screen.blit(game.background, (0, 0))
    game.menu.display_text(game.menu.title_font, "Space Heroic", 145, 200, game.menu.default_color)
    game.menu.display_text(game.menu.option_font, "Play", 145, 350, game.menu.play_color)
    game.menu.display_text(game.menu.option_font, "Exit", 145, 400, game.menu.exit_color)

    for event in pygame.event.get():

        if event.type == pygame.KEYDOWN:

            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

            if event.key == pygame.K_UP or event.key == pygame.K_w:
                game.menu.play_color = (87, 35, 100)
                game.menu.exit_color = (255, 255, 255)

            if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                game.menu.play_color = (255, 255, 255)
                game.menu.exit_color = (87, 35, 100)

            if event.key == pygame.K_RETURN and game.menu.play_color == (87, 35, 100):
                game.menu.execute = False

            if event.key == pygame.K_RETURN and game.menu.exit_color == (87, 35, 100):
                pygame.quit()
                exit()

    # Updating the screen.
    pygame.display.flip()


def in_game_inputs():

    # for each tick in game execute the next block.
    for event in pygame.event.get():

        # Close Game
        if event.type == pygame.QUIT:
            pygame.quit()
            exit()

        # If a key is pressed, the next block will be executed.
        if event.type == pygame.KEYDOWN:

            # If the key pressed is "right arrow" or "d", the next block will be executed.
            if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                for iteration in range(player.quantity):
                    player.move_to_right(iteration, 1.8)

            # If the key pressed is "left arrow" or "a", the next block will be executed.
            if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                for iteration in range(player.quantity):
                    player.move_to_left(iteration, -1.8)

            # If the key pressed is space, the next block will be executed.
            if event.key == pygame.K_SPACE:

                for iteration in range(bullet.quantity):
                    bullet.visible = True
                    bullet.sound.play()
                    bullet.shoot(iteration, -12)

        # This is an event I set to be called every millisecond.
        if event.type == pygame.USEREVENT:
            timer.update_time()


# # Function that makes every specified object to move.
def movable_objects():

    # Displaying the background image on the screen.
    game.screen.blit(game.background, (0, 0))

    # Player functions -------------------------------------------------------------------------------------------------
    for iteration in range(player.quantity):

        # Updating the player's position.
        player.update_position(iteration, player.image_path)

        # If the position in the X axis of the player is 0 or below, the next block will be executed.
        if player.position_x[iteration] <= 0:
            player.stop_player_left(iteration)

        # If the position in the X axis of the player is 0 or below, the next block will be executed.
        if player.position_x[iteration] >= 734:
            player.stop_player_right(iteration)

    # Enemies functions ------------------------------------------------------------------------------------------------
    for enemy in range(enemies.quantity):

        # Updating enemies' position.
        enemies.update_position(enemy, enemies.image_path)

        # Updating the position of the enemy whenever they hit the screen limits.
        if enemies.position_x[enemy] >= 736:
            enemies.move_to_left(enemy, -1)
            enemies.move_down(enemy)

        if enemies.position_x[enemy] <= 0:
            enemies.move_to_right(enemy, 1)
            enemies.move_down(enemy)

        # Ending the game due to a enemy ship passing through the player.
        if enemies.position_y[enemy] >= 550:
            game.over = True
            game.execute = False

        # Collisions ---------------------------------------------------------------------------------------------------
        for iteration in range(bullet.quantity):


            # Storaging the collision between the bullet and the enemy and between the player and the enemy.
            collision_bullet_n_enemy = hitbox(enemies.position_x[enemy], enemies.position_y[enemy],
                                              bullet.position_x[iteration], bullet.position_y[iteration],
                                              28)

            # Storaging the collision between the bullet and the enemy and between the player and the enemy.
            collision_player_n_enemy = hitbox(enemies.position_x[enemy], enemies.position_y[enemy],
                                              player.position_x[iteration], player.position_y[iteration],
                                              60)

            collision_player_n_meteor = hitbox(player.position_x[iteration], player.position_y[iteration],
                                               meteors.position_x[iteration], meteors.position_y[iteration],
                                               100)

            # If there is a collision between the bullet and an enemy, the next block will be executed.
            if collision_bullet_n_enemy:
                game.destruction_sound.stop()
                game.destruction_sound.play()
                game.update_score()

                # Difficulty curve
                enemies.regenerate_object(enemy, 0, 200, 500, False, 0)
                enemies.regenerate_object(enemy, 0, 225, 1000, False, 500)
                enemies.regenerate_object(enemy, 0, 250, 1500, False, 1000)
                enemies.regenerate_object(enemy, 0, 275, 2000, False, 1500)
                enemies.regenerate_object(enemy, 0, 300, 2000, True)



                # Bullet won't be longer visible until space key is pressed again.
                bullet.visible = False

            # If there is a collision between the player and an enemy, the next block will be executed.
            if collision_player_n_enemy:

                # Ending the game and activating the game over screen.
                game.execute = False
                game.over = True

            if collision_player_n_meteor:

                # Ending the game and activating the game over screen.
                game.execute = False
                game.over = True


    # Bullet functions -------------------------------------------------------------------------------------------------
    for iteration in range(bullet.quantity):

        # If the bullet attribute "visible" is true, the next block will be executed.
        if not bullet.visible:
            bullet.follow_ship(iteration, 15, 0)

        # If the bullet attribute "visible" is not true, the next block will be executed.
        if bullet.visible:
            bullet.update_position(iteration, bullet.image_path)

        # If bullet position in the Y axis is below -64 pixels, the next block will be executed.
        if bullet.position_y[iteration] <= -64:

            # Bullet is no longer visible until space key is pressed again.
            bullet.visible = False

            # In this Y coordinate the bullet reappears.
            bullet.position_y[iteration] = 518

    # Meteors ----------------------------------------------------------------------------------------------------------
    # if score is greater than 750 points, but lower than 1500 points, the next block will be executed.
    if 750 < game.score <= 1500:

        for iteration in range(1):

            if not meteors.visible:
                meteors.regenerate_object(iteration, 0, 0, False, random.randint(0, 736), -128)
                meteors.visible = True

            if meteors.visible:
                meteors.shoot(iteration, 2)
                meteors.update_position(iteration, meteors.image_path)

            if meteors.position_y[iteration] >= 826:
                meteors.visible = False

    if 1500 < game.score:
        for iteration in range(2):

            if not meteors.visible:
                meteors.regenerate_object(iteration, 0, 0, False, random.randint(0, 736),
                                          random.randint(-256, -128))
                meteors.visible = True

            if meteors.visible:
                meteors.shoot(iteration, 2)
                meteors.update_position(iteration, meteors.image_path)

            if meteors.position_y[0] and meteors.position_y[1] >= 826:
                meteors.visible = False







def game_over():

    # Stopping the music.
    mixer.music.stop()

    # Setting the background to a black image.
    game.screen.fill((0, 0, 0))

    for iteration in range(game.destruction_sprite.quantity):

        player.stand_by(iteration)
        game.destruction_sprite.follow_ship(iteration, 0, 0)

        if timer.seconds < 0.39:
            player.update_position(iteration, player.image_path)

        if timer.seconds <= 0.08:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.image_path)

        if 0.08 < timer.seconds <= 0.16:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.frame02)

        if 0.16 < timer.seconds <= 0.24:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.frame03)

        if 0.24 < timer.seconds <= 0.4:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.frame04)

    if timer.seconds < 1.5:
        player.death_sound.play()

    if timer.seconds > 2:
        game.game_over_text(game.title_font, "Game Over", 200, 200, game.default_color)

    if timer.seconds > 3:

        game.display_text(game.option_font, "Try Again", 160, 300, game.play_color)
        game.display_text(game.option_font, "Exit", 160, 340, game.exit_color)

    for event in pygame.event.get():

        if event.type == pygame.QUIT:
            pygame.quit()
            exit()

        if event.type == pygame.USEREVENT:
            timer.update_time()

        if event.type == pygame.KEYDOWN:

            if event.key == pygame.K_UP or event.key == pygame.K_w:
                game.play_color = (87, 35, 100)
                game.exit_color = (255, 255, 255)

            if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                game.play_color = (255, 255, 255)
                game.exit_color = (87, 35, 100)

            if event.key == pygame.K_RETURN and game.play_color == (87, 35, 100):
                game.reset = True
                game.execute = True
                game.menu.execute = False
                game.over = False

            if event.key == pygame.K_RETURN and game.exit_color == (87, 35, 100):
                pygame.quit()
                exit()

    pygame.display.flip()
