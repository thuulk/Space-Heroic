# Module created to define and store classes of Space_Heroic source code

from classes import game, bullet, enemies, player, timer
from pygame import mixer
import pygame
import math


def initialize():

    pygame.init()

    # Initialize music and main theme
    pygame.mixer.init()
    mixer.music.load('corneria.mp3')
    mixer.music.set_volume(1)
    mixer.music.play(-1)

    # Setting the frame rate in which the screen updates.
    timer.clock.tick(60)

    # Respawning enemies and player
    for enemy in range(enemies.quantity):
        enemies.regenerate(enemy, 200)

    for iteration in range(player.quantity):
        player.regenerate_object(iteration, 368, 518)
        bullet.position_y_change[iteration] = 0

    # Resetting score
    game.score = 0


def reinitialize_music():

    mixer.music.stop()
    mixer.music.play()


# Hitbox function
def hitbox(position_x_1, position_y_1, position_x_2, position_y_2, distance_pixels):

    bullet_n_enemy_distance = math.sqrt(math.pow(position_x_1 - position_x_2, 2) +
                                        math.pow(position_y_1 - position_y_2, 2))

    if bullet_n_enemy_distance < distance_pixels:
        return True

    else:
        return False


def game_menu():
    game.screen.blit(game.background, (0, 0))
    game.menu.display_text(game.menu.title_font, "Space Invaders", 100, 200, game.menu.default_color)
    game.menu.display_text(game.menu.option_font, "Play", 145, 350, game.menu.play_color)
    game.menu.display_text(game.menu.option_font, "Quit", 145, 400, game.menu.exit_color)

    for event in pygame.event.get():

        if event.type == pygame.KEYDOWN:

            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

            if event.key == pygame.K_UP or event.key == pygame.K_w:
                game.menu.play_color = (87, 35, 100)
                game.menu.exit_color = (255, 255, 255)

            if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                game.menu.play_color = (255, 255, 255)
                game.menu.exit_color = (87, 35, 100)

            if event.key == pygame.K_RETURN and game.menu.play_color == (87, 35, 100):
                game.menu.execute = False

            if event.key == pygame.K_RETURN and game.menu.exit_color == (87, 35, 100):
                pygame.quit()
                exit()

    # Updating the screen.
    pygame.display.flip()


def in_game_inputs():

    # for each tick in game execute the next block.
    for event in pygame.event.get():

        # Close Game
        if event.type == pygame.QUIT:
            pygame.quit()
            exit()

        # If a key is pressed, the next block will be executed.
        if event.type == pygame.KEYDOWN:

            # If the key pressed is "right arrow" or "d", the next block will be executed.
            if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                for iteration in range(player.quantity):
                    player.move_to_right(iteration, 2)

            # If the key pressed is "left arrow" or "a", the next block will be executed.
            if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                for iteration in range(player.quantity):
                    player.move_to_left(iteration, -2)

            # If the key pressed is space, the next block will be executed.
            if event.key == pygame.K_SPACE:

                for iteration in range(bullet.quantity):
                    bullet.visible = True
                    bullet.sound.play()
                    bullet.shoot(iteration)

        if event.type == pygame.USEREVENT:
            timer.update_time()


def movable_objects():

    # Player functions -------------------------------------------------------------------------------------------------
    for iteration in range(player.quantity):

        player.update_position(iteration, player.image_path)

        # If the position in the X axis of the player is 0 or below, the next block will be executed.
        if player.position_x[iteration] <= 0:
            player.stop_player_left(iteration)

        # If the position in the X axis of the player is 0 or below, the next block will be executed.
        if player.position_x[iteration] >= 734:
            player.stop_player_right(iteration)

    # Enemies functions ------------------------------------------------------------------------------------------------
    for enemy in range(enemies.quantity):

        enemies.update_position(enemy, enemies.image_path)

        # Updating the position of the enemy
        if enemies.position_x[enemy] >= 736:
            enemies.move_to_left(enemy, -0.8)
            enemies.move_down(enemy)

        if enemies.position_x[enemy] <= 0:
            enemies.move_to_right(enemy, 0.8)
            enemies.move_down(enemy)

        if enemies.position_y[enemy] >= 550:
            game.over = True
            game.execute = False

        # Collisions ---------------------------------------------------------------------------------------------------
        for iteration in range(bullet.quantity):
            enemies.update_position(enemy, enemies.image_path)

            # Collision between the bullet and the enemy and between the player and the enemy.
            collision_bullet_n_enemy = hitbox(enemies.position_x[enemy], enemies.position_y[enemy],
                                              bullet.position_x[iteration], bullet.position_y[iteration], 27)

            # Collision between the bullet and the enemy and between the player and the enemy.
            collision_player_n_enemy = hitbox(enemies.position_x[enemy], enemies.position_y[enemy],
                                              player.position_x[iteration], player.position_y[iteration], 60)

            # If there is a collision between the bullet and an enemy, the next block will be executed.
            if collision_bullet_n_enemy:
                game.destruction_sound.stop()
                game.destruction_sound.play()
                game.update_score()

                if game.score < 200:
                    enemies.regenerate(enemy, 200)

                if game.score > 200:
                    enemies.regenerate(enemy, 300)

                bullet.visible = False

            if collision_player_n_enemy:

                game.execute = False
                game.destruction_sprite.visible = False
                game.over = True

    # Bullet functions -------------------------------------------------------------------------------------------------
    for iteration in range(bullet.quantity):

        # If the bullet attribute "visible" is true, the next block will be executed.
        if not bullet.visible:
            bullet.follow_ship(iteration, 15, 0)

        # If the bullet attribute "visible" is not true, the next block will be executed.
        if bullet.visible:
            bullet.update_position(iteration, bullet.image_path)

        # If bullet position in the Y axis is below -64 pixels, the next block will be executed.
        if bullet.position_y[iteration] <= -64:
            bullet.visible = False

            # In this Y coordinate, the bullet is hidden by the player sprite.
            bullet.position_y[iteration] = 518


def game_over():

    mixer.music.stop()
    game.screen.fill((0, 0, 0))

    for iteration in range(game.destruction_sprite.quantity):

        player.stand_by(iteration)
        game.destruction_sprite.follow_ship(iteration, 0, 0)

        if timer.seconds < 0.39:
            player.update_position(iteration, player.image_path)

        if timer.seconds <= 0.08:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.image_path)

        if 0.08 < timer.seconds <= 0.16:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.frame02)

        if 0.16 < timer.seconds <= 0.24:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.frame03)

        if 0.24 < timer.seconds <= 0.4:
            game.destruction_sprite.update_position(iteration, game.destruction_sprite.frame04)

    if timer.seconds < 1.5:
        player.death_sound.play()

    if timer.seconds > 2:
        game.game_over_text(game.title_font, "Game Over", 200, 200, game.default_color)

    if timer.seconds > 3:

        game.display_text(game.option_font, "Try Again", 160, 300, game.play_color)
        game.display_text(game.option_font, "Exit", 160, 340, game.exit_color)

    for event in pygame.event.get():

        if event.type == pygame.QUIT:
            pygame.quit()
            exit()

        if event.type == pygame.USEREVENT:
            timer.update_time()

        if event.type == pygame.KEYDOWN:

            if event.key == pygame.K_UP or event.key == pygame.K_w:
                game.play_color = (87, 35, 100)
                game.exit_color = (255, 255, 255)

            if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                game.play_color = (255, 255, 255)
                game.exit_color = (87, 35, 100)

            if event.key == pygame.K_RETURN and game.play_color == (87, 35, 100):
                game.reset = True
                game.execute = True
                game.menu.execute = False
                game.over = False

            if event.key == pygame.K_RETURN and game.exit_color == (87, 35, 100):
                pygame.quit()
                exit()

    pygame.display.flip()
